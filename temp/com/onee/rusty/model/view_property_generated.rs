// automatically generated by the FlatBuffers compiler, do not modify
extern crate flatbuffers;
use std::mem;
use std::cmp::Ordering;
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum ViewPropertyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ViewProperty<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ViewProperty<'a> {
  type Inner = ViewProperty<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ViewProperty<'a> {
  pub const VT_WIDTH: flatbuffers::VOffsetT = 4;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;
  pub const VT_MARGIN_LEFT: flatbuffers::VOffsetT = 8;
  pub const VT_MARGIN_RIGHT: flatbuffers::VOffsetT = 10;
  pub const VT_MARGIN_TOP: flatbuffers::VOffsetT = 12;
  pub const VT_MARGIN_BOTTOM: flatbuffers::VOffsetT = 14;
  pub const VT_FLEX: flatbuffers::VOffsetT = 16;
  pub const VT_DISPLAY: flatbuffers::VOffsetT = 18;
  pub const VT_FLEX_DIRECTION: flatbuffers::VOffsetT = 20;
  pub const VT_BACKGROUND_COLOR: flatbuffers::VOffsetT = 22;
  pub const VT_FLEX_WRAP: flatbuffers::VOffsetT = 24;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ViewProperty { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ViewPropertyArgs
  ) -> flatbuffers::WIPOffset<ViewProperty<'bldr>> {
    let mut builder = ViewPropertyBuilder::new(_fbb);
    builder.add_margin_bottom(args.margin_bottom);
    builder.add_margin_top(args.margin_top);
    builder.add_margin_right(args.margin_right);
    builder.add_margin_left(args.margin_left);
    builder.add_height(args.height);
    builder.add_width(args.width);
    builder.add_flex_wrap(args.flex_wrap);
    builder.add_background_color(args.background_color);
    builder.add_flex_direction(args.flex_direction);
    builder.add_display(args.display);
    builder.add_flex(args.flex);
    builder.finish()
  }


  #[inline]
  pub fn width(&self) -> f64 {
    self._tab.get::<f64>(ViewProperty::VT_WIDTH, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn height(&self) -> f64 {
    self._tab.get::<f64>(ViewProperty::VT_HEIGHT, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn margin_left(&self) -> f64 {
    self._tab.get::<f64>(ViewProperty::VT_MARGIN_LEFT, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn margin_right(&self) -> f64 {
    self._tab.get::<f64>(ViewProperty::VT_MARGIN_RIGHT, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn margin_top(&self) -> f64 {
    self._tab.get::<f64>(ViewProperty::VT_MARGIN_TOP, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn margin_bottom(&self) -> f64 {
    self._tab.get::<f64>(ViewProperty::VT_MARGIN_BOTTOM, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn flex(&self) -> i32 {
    self._tab.get::<i32>(ViewProperty::VT_FLEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn display(&self) -> Display {
    self._tab.get::<Display>(ViewProperty::VT_DISPLAY, Some(Display::flex)).unwrap()
  }
  #[inline]
  pub fn flex_direction(&self) -> FlexDirection {
    self._tab.get::<FlexDirection>(ViewProperty::VT_FLEX_DIRECTION, Some(FlexDirection::column)).unwrap()
  }
  #[inline]
  pub fn background_color(&self) -> i32 {
    self._tab.get::<i32>(ViewProperty::VT_BACKGROUND_COLOR, Some(0)).unwrap()
  }
  #[inline]
  pub fn flex_wrap(&self) -> FlexWrap {
    self._tab.get::<FlexWrap>(ViewProperty::VT_FLEX_WRAP, Some(FlexWrap::nowrap)).unwrap()
  }
}

impl flatbuffers::Verifiable for ViewProperty<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .visit_field::<f64>("height", Self::VT_HEIGHT, false)?
     .visit_field::<f64>("margin_left", Self::VT_MARGIN_LEFT, false)?
     .visit_field::<f64>("margin_right", Self::VT_MARGIN_RIGHT, false)?
     .visit_field::<f64>("margin_top", Self::VT_MARGIN_TOP, false)?
     .visit_field::<f64>("margin_bottom", Self::VT_MARGIN_BOTTOM, false)?
     .visit_field::<i32>("flex", Self::VT_FLEX, false)?
     .visit_field::<Display>("display", Self::VT_DISPLAY, false)?
     .visit_field::<FlexDirection>("flex_direction", Self::VT_FLEX_DIRECTION, false)?
     .visit_field::<i32>("background_color", Self::VT_BACKGROUND_COLOR, false)?
     .visit_field::<FlexWrap>("flex_wrap", Self::VT_FLEX_WRAP, false)?
     .finish();
    Ok(())
  }
}
pub struct ViewPropertyArgs {
    pub width: f64,
    pub height: f64,
    pub margin_left: f64,
    pub margin_right: f64,
    pub margin_top: f64,
    pub margin_bottom: f64,
    pub flex: i32,
    pub display: Display,
    pub flex_direction: FlexDirection,
    pub background_color: i32,
    pub flex_wrap: FlexWrap,
}
impl<'a> Default for ViewPropertyArgs {
  #[inline]
  fn default() -> Self {
    ViewPropertyArgs {
      width: 0.0,
      height: 0.0,
      margin_left: 0.0,
      margin_right: 0.0,
      margin_top: 0.0,
      margin_bottom: 0.0,
      flex: 0,
      display: Display::flex,
      flex_direction: FlexDirection::column,
      background_color: 0,
      flex_wrap: FlexWrap::nowrap,
    }
  }
}
pub struct ViewPropertyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ViewPropertyBuilder<'a, 'b> {
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(ViewProperty::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_height(&mut self, height: f64) {
    self.fbb_.push_slot::<f64>(ViewProperty::VT_HEIGHT, height, 0.0);
  }
  #[inline]
  pub fn add_margin_left(&mut self, margin_left: f64) {
    self.fbb_.push_slot::<f64>(ViewProperty::VT_MARGIN_LEFT, margin_left, 0.0);
  }
  #[inline]
  pub fn add_margin_right(&mut self, margin_right: f64) {
    self.fbb_.push_slot::<f64>(ViewProperty::VT_MARGIN_RIGHT, margin_right, 0.0);
  }
  #[inline]
  pub fn add_margin_top(&mut self, margin_top: f64) {
    self.fbb_.push_slot::<f64>(ViewProperty::VT_MARGIN_TOP, margin_top, 0.0);
  }
  #[inline]
  pub fn add_margin_bottom(&mut self, margin_bottom: f64) {
    self.fbb_.push_slot::<f64>(ViewProperty::VT_MARGIN_BOTTOM, margin_bottom, 0.0);
  }
  #[inline]
  pub fn add_flex(&mut self, flex: i32) {
    self.fbb_.push_slot::<i32>(ViewProperty::VT_FLEX, flex, 0);
  }
  #[inline]
  pub fn add_display(&mut self, display: Display) {
    self.fbb_.push_slot::<Display>(ViewProperty::VT_DISPLAY, display, Display::flex);
  }
  #[inline]
  pub fn add_flex_direction(&mut self, flex_direction: FlexDirection) {
    self.fbb_.push_slot::<FlexDirection>(ViewProperty::VT_FLEX_DIRECTION, flex_direction, FlexDirection::column);
  }
  #[inline]
  pub fn add_background_color(&mut self, background_color: i32) {
    self.fbb_.push_slot::<i32>(ViewProperty::VT_BACKGROUND_COLOR, background_color, 0);
  }
  #[inline]
  pub fn add_flex_wrap(&mut self, flex_wrap: FlexWrap) {
    self.fbb_.push_slot::<FlexWrap>(ViewProperty::VT_FLEX_WRAP, flex_wrap, FlexWrap::nowrap);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ViewPropertyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ViewPropertyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ViewProperty<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ViewProperty<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ViewProperty");
      ds.field("width", &self.width());
      ds.field("height", &self.height());
      ds.field("margin_left", &self.margin_left());
      ds.field("margin_right", &self.margin_right());
      ds.field("margin_top", &self.margin_top());
      ds.field("margin_bottom", &self.margin_bottom());
      ds.field("flex", &self.flex());
      ds.field("display", &self.display());
      ds.field("flex_direction", &self.flex_direction());
      ds.field("background_color", &self.background_color());
      ds.field("flex_wrap", &self.flex_wrap());
      ds.finish()
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_view_property<'a>(buf: &'a [u8]) -> ViewProperty<'a> {
  unsafe { flatbuffers::root_unchecked::<ViewProperty<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_view_property<'a>(buf: &'a [u8]) -> ViewProperty<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<ViewProperty<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `ViewProperty`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_view_property_unchecked`.
pub fn root_as_view_property(buf: &[u8]) -> Result<ViewProperty, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ViewProperty>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ViewProperty` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_view_property_unchecked`.
pub fn size_prefixed_root_as_view_property(buf: &[u8]) -> Result<ViewProperty, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ViewProperty>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ViewProperty` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_view_property_unchecked`.
pub fn root_as_view_property_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ViewProperty<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ViewProperty<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ViewProperty` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_view_property_unchecked`.
pub fn size_prefixed_root_as_view_property_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ViewProperty<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ViewProperty<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ViewProperty and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ViewProperty`.
pub unsafe fn root_as_view_property_unchecked(buf: &[u8]) -> ViewProperty {
  flatbuffers::root_unchecked::<ViewProperty>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ViewProperty and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ViewProperty`.
pub unsafe fn size_prefixed_root_as_view_property_unchecked(buf: &[u8]) -> ViewProperty {
  flatbuffers::size_prefixed_root_unchecked::<ViewProperty>(buf)
}
#[inline]
pub fn finish_view_property_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<ViewProperty<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_view_property_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<ViewProperty<'a>>) {
  fbb.finish_size_prefixed(root, None);
}

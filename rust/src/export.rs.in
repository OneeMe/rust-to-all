use jni::sys::*;

use crate::bench::*;
use crate::core::collection::*;
use crate::core::property::*;
use crate::core::*;

foreign_enum!(
    enum ValueType {
        Null = ValueType::Null,
        Boolean = ValueType::Boolean,
        Number = ValueType::Number,
        String = ValueType::String,
        Map = ValueType::Map,
        Array = ValueType::Array,
    }
);

foreign_typemap!(
    ($p:r_type) Vec<ValueType> => Vec<i32> {
        $out = $p.iter().map(|ele| ele.to_owned() as i32).collect();
    };
);

foreign_class!(class CollectionValue {
    self_type CollectionValue;
    private constructor = empty;
    fn PropertyVale::property_type(&self) -> ValueType {
        this.property_type.clone()
    }
    fn CollectionValue::as_bool(&self) -> bool {
        this.value.as_bool().unwrap()
    }
    fn CollectionValue::as_string(&self) -> String {
        this.value.as_str().unwrap().to_owned()
    }
    fn CollectionValue::as_map(&self) -> CollectionMap {
        CollectionMap::new(this.value.as_object().unwrap().clone())
    }
    fn CollectionValue::as_array(&self) -> CollectionList {
        CollectionList::new(this.value.as_array().unwrap().clone())
    }
    fn CollectionValue::as_number(&self) -> f64 {
        this.value.as_f64().unwrap()
    }
    foreign_code r#"
    public Object getValue() {
        switch (property_type()) {
            case Null:
                return null;
            case Number:
                return as_number();
            case Boolean:
                return as_bool();
            case String:
                return as_string();
            case Map:
                return as_map();
            case Array:
                return as_array();
            default:
                throw new IllegalStateException("Unexpected value: " + property_type());
        }
    }
    "#;
});

foreign_class!(class CollectionMap {
    self_type CollectionMap;
    private constructor = empty;
    fn CollectionMap::import_keys(&self) -> Vec<String>; alias importKeys;
    fn CollectionMap::import_values(&self) -> Vec<CollectionValue>; alias importValues;
    fn CollectionMap::import_types(&self) -> Vec<ValueType>; alias rawImportTypes;
    foreign_code r#"
    public ValueType[] importTypes() {
        int[] rawTypes = rawImportTypes();
        ValueType[] types = new ValueType[rawTypes.length];
        for (int i = 0;i < types.length;i++) {
            types[i] = ValueType.fromInt(rawTypes[i]);
        }
        return types;
    }
    "#;
});

foreign_class!(class CollectionList {
    self_type CollectionList;
    private constructor = empty;
    fn CollectionList::import_values(&self) -> Vec<CollectionValue>; alias importValues;
    fn CollectionList::import_types(&self) -> Vec<ValueType>; alias rawImportTypes;
    foreign_code r#"
    public ValueType[] importTypes() {
        int[] rawTypes = rawImportTypes();
        ValueType[] types = new ValueType[rawTypes.length];
        for (int i = 0;i < types.length;i++) {
            types[i] = ValueType.fromInt(rawTypes[i]);
        }
        return types;
    }
    "#;
});

foreign_callback!(
    callback UIManager {
        self_type UIManager;
        createView = create_view(&self, tag: i32, class_name: &str, root_view_tag: i32, properties: CollectionMap);
        setChildren = set_children(&self, tag: i32, children: Vec<i32>);
        updateView = update_view(&self, tag: i32, class_name: &str, properties: CollectionMap);
        manageChildren = manage_children(
            &self,
            tag: i32,
            move_from: Vec<i32>,
            move_to: Vec<i32>,
            added_children: Vec<i32>,
            add_at_indices: Vec<i32>,
            remove_from: Vec<i32>,
        );
        onBatchComplete = on_batch_complete(&self);
    }
);

foreign_enum!(
    enum Display {
        flex = Display::flex,
        none = Display::none,
    }
);

foreign_enum!(
    enum FlexDirection {
        column = FlexDirection::column,
        column_reverse = FlexDirection::column_reverse,
        row = FlexDirection::row,
        row_reverse = FlexDirection::row_reverse,
    }
);

foreign_enum!(
    enum FlexWrap {
        nowrap = FlexWrap::nowrap,
        wrap = FlexWrap::wrap,
    }
);

foreign_class!(class ViewProperty {
    self_type ViewProperty;
    private constructor = empty;
    fn ViewProperty::width(&self) -> f64 {
        this.width.clone()
    }
    fn ViewProperty::height(&self) -> f64 {
        this.height.clone()
    }
    fn ViewProperty::marginLeft(&self) -> f64 {
        this.margin_left.clone()
    }
    fn ViewProperty::marginRight(&self) -> f64 {
        this.margin_right.clone()
    }
    fn ViewProperty::marginTop(&self) -> f64 {
        this.margin_top.clone()
    }
    fn ViewProperty::marginBottom(&self) -> f64 {
        this.margin_bottom.clone()
    }
    fn ViewProperty::flex(&self) -> i32 {
        this.flex.clone()
    }
    fn ViewProperty::display(&self) -> Display {
        this.display.clone()
    }
    fn ViewProperty::flexDirection(&self) -> FlexDirection {
        this.flex_direction.clone()
    }
    fn ViewProperty::backgroundColor(&self) -> i32 {
        this.background_color.clone()
    }
    fn ViewProperty::flexWrap(&self) -> FlexWrap {
        this.flex_wrap.clone()
    }
    fn ViewProperty::content(&self) -> String {
        this.content.clone()
    }
    fn ViewProperty::a(&self) -> String {
        this.a.clone()
    }
    fn ViewProperty::b(&self) -> String {
        this.b.clone()
    }
    fn ViewProperty::c(&self) -> String {
        this.c.clone()
    }
    fn ViewProperty::d(&self) -> String {
        this.d.clone()
    }
    fn ViewProperty::e(&self) -> String {
        this.e.clone()
    }
    fn ViewProperty::f(&self) -> String {
        this.f.clone()
    }
    fn ViewProperty::g(&self) -> String {
        this.g.clone()
    }
    fn ViewProperty::h(&self) -> String {
        this.h.clone()
    }
    fn ViewProperty::i(&self) -> String {
        this.i.clone()
    }
    fn ViewProperty::j(&self) -> String {
        this.j.clone()
    }
    fn ViewProperty::k(&self) -> String {
        this.k.clone()
    }
    fn ViewProperty::l(&self) -> String {
        this.l.clone()
    }
    fn ViewProperty::m(&self) -> String {
        this.m.clone()
    }
    fn ViewProperty::n(&self) -> String {
        this.n.clone()
    }
    fn ViewProperty::o(&self) -> String {
        this.o.clone()
    }
});

// From https://github.com/Dushistov/flapigen-rs/issues/143#issuecomment-664131615
foreign_typemap!(
    ($p:r_type) Vec<u8> => jbyteArray {
        let slice = &($p)[..];
        let slice = unsafe { std::mem::transmute::<&[u8], &[i8]>(slice) };
        let raw = JavaByteArray::from_slice_to_raw(slice, env);
        $out = raw;
    };
    ($p:f_type) => "jbyteArray";
);
// From https://github.com/Dushistov/flapigen-rs/issues/143#issuecomment-664131615
foreign_typemap!(
    ($p:r_type) &'a [u8] => jbyteArray {
        let slice = unsafe { std::mem::transmute::<&[u8], &[i8]>($p) };
        let raw = JavaByteArray::from_slice_to_raw(slice, env);
        $out = raw;
    };
    ($p:f_type) => "jbyteArray";
    ($p:r_type) &'a [u8] <= jbyteArray {
        let arr = JavaByteArray::new(env, $p);
        let slice = arr.to_slice();
        let slice = unsafe { std::mem::transmute::<&[i8], &[u8]>(slice) };
        $out = slice;
    };
    ($p:f_type) <= "jbyteArray";
);

foreign_callback!(callback FromRustToJavaBench {
    self_type FromRustToJavaBench;
    callEmpty = call_empty(&self);
    callUseFlapigen = call_use_flapigen(&self, args: ViewProperty, read: bool);
    callUseJson = call_use_json(&self, args: String, read: bool);
    callUseFlexbuffer = call_use_flexbuffer(&self, args: Vec<u8>, read: bool);
});

foreign_class!(class Engine {
    self_type Engine;
    constructor Engine::new(manager: Box<dyn UIManager>) -> Engine;
    fn Engine::launch(&self) -> ();
    fn Engine::run_bench(&self, bench: Box<dyn FromRustToJavaBench>) -> ();
    fn Engine::run_app(&self, _: i32) -> (); alias runApp;
});

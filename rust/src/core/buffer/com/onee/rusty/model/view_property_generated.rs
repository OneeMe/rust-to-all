// automatically generated by the FlatBuffers compiler, do not modify
extern crate flatbuffers;
use std::mem;
use std::cmp::Ordering;
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum ViewPropertyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ViewProperty<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ViewProperty<'a> {
  type Inner = ViewProperty<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ViewProperty<'a> {
  pub const VT_WIDTH: flatbuffers::VOffsetT = 4;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;
  pub const VT_MARGIN_LEFT: flatbuffers::VOffsetT = 8;
  pub const VT_MARGIN_RIGHT: flatbuffers::VOffsetT = 10;
  pub const VT_MARGIN_TOP: flatbuffers::VOffsetT = 12;
  pub const VT_MARGIN_BOTTOM: flatbuffers::VOffsetT = 14;
  pub const VT_FLEX: flatbuffers::VOffsetT = 16;
  pub const VT_DISPLAY: flatbuffers::VOffsetT = 18;
  pub const VT_FLEX_DIRECTION: flatbuffers::VOffsetT = 20;
  pub const VT_BACKGROUND_COLOR: flatbuffers::VOffsetT = 22;
  pub const VT_FLEX_WRAP: flatbuffers::VOffsetT = 24;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 26;
  pub const VT_A: flatbuffers::VOffsetT = 28;
  pub const VT_B: flatbuffers::VOffsetT = 30;
  pub const VT_C: flatbuffers::VOffsetT = 32;
  pub const VT_D: flatbuffers::VOffsetT = 34;
  pub const VT_E: flatbuffers::VOffsetT = 36;
  pub const VT_F: flatbuffers::VOffsetT = 38;
  pub const VT_G: flatbuffers::VOffsetT = 40;
  pub const VT_H: flatbuffers::VOffsetT = 42;
  pub const VT_I: flatbuffers::VOffsetT = 44;
  pub const VT_J: flatbuffers::VOffsetT = 46;
  pub const VT_K: flatbuffers::VOffsetT = 48;
  pub const VT_L: flatbuffers::VOffsetT = 50;
  pub const VT_M: flatbuffers::VOffsetT = 52;
  pub const VT_N: flatbuffers::VOffsetT = 54;
  pub const VT_O: flatbuffers::VOffsetT = 56;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ViewProperty { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ViewPropertyArgs<'args>
  ) -> flatbuffers::WIPOffset<ViewProperty<'bldr>> {
    let mut builder = ViewPropertyBuilder::new(_fbb);
    builder.add_margin_bottom(args.margin_bottom);
    builder.add_margin_top(args.margin_top);
    builder.add_margin_right(args.margin_right);
    builder.add_margin_left(args.margin_left);
    builder.add_height(args.height);
    builder.add_width(args.width);
    if let Some(x) = args.o { builder.add_o(x); }
    if let Some(x) = args.n { builder.add_n(x); }
    if let Some(x) = args.m { builder.add_m(x); }
    if let Some(x) = args.l { builder.add_l(x); }
    if let Some(x) = args.k { builder.add_k(x); }
    if let Some(x) = args.j { builder.add_j(x); }
    if let Some(x) = args.i { builder.add_i(x); }
    if let Some(x) = args.h { builder.add_h(x); }
    if let Some(x) = args.g { builder.add_g(x); }
    if let Some(x) = args.f { builder.add_f(x); }
    if let Some(x) = args.e { builder.add_e(x); }
    if let Some(x) = args.d { builder.add_d(x); }
    if let Some(x) = args.c { builder.add_c(x); }
    if let Some(x) = args.b { builder.add_b(x); }
    if let Some(x) = args.a { builder.add_a(x); }
    if let Some(x) = args.content { builder.add_content(x); }
    builder.add_flex_wrap(args.flex_wrap);
    builder.add_background_color(args.background_color);
    builder.add_flex_direction(args.flex_direction);
    builder.add_display(args.display);
    builder.add_flex(args.flex);
    builder.finish()
  }


  #[inline]
  pub fn width(&self) -> f64 {
    self._tab.get::<f64>(ViewProperty::VT_WIDTH, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn height(&self) -> f64 {
    self._tab.get::<f64>(ViewProperty::VT_HEIGHT, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn margin_left(&self) -> f64 {
    self._tab.get::<f64>(ViewProperty::VT_MARGIN_LEFT, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn margin_right(&self) -> f64 {
    self._tab.get::<f64>(ViewProperty::VT_MARGIN_RIGHT, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn margin_top(&self) -> f64 {
    self._tab.get::<f64>(ViewProperty::VT_MARGIN_TOP, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn margin_bottom(&self) -> f64 {
    self._tab.get::<f64>(ViewProperty::VT_MARGIN_BOTTOM, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn flex(&self) -> i32 {
    self._tab.get::<i32>(ViewProperty::VT_FLEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn display(&self) -> Display {
    self._tab.get::<Display>(ViewProperty::VT_DISPLAY, Some(Display::flex)).unwrap()
  }
  #[inline]
  pub fn flex_direction(&self) -> FlexDirection {
    self._tab.get::<FlexDirection>(ViewProperty::VT_FLEX_DIRECTION, Some(FlexDirection::column)).unwrap()
  }
  #[inline]
  pub fn background_color(&self) -> i32 {
    self._tab.get::<i32>(ViewProperty::VT_BACKGROUND_COLOR, Some(0)).unwrap()
  }
  #[inline]
  pub fn flex_wrap(&self) -> FlexWrap {
    self._tab.get::<FlexWrap>(ViewProperty::VT_FLEX_WRAP, Some(FlexWrap::nowrap)).unwrap()
  }
  #[inline]
  pub fn content(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ViewProperty::VT_CONTENT, None)
  }
  #[inline]
  pub fn a(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ViewProperty::VT_A, None)
  }
  #[inline]
  pub fn b(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ViewProperty::VT_B, None)
  }
  #[inline]
  pub fn c(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ViewProperty::VT_C, None)
  }
  #[inline]
  pub fn d(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ViewProperty::VT_D, None)
  }
  #[inline]
  pub fn e(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ViewProperty::VT_E, None)
  }
  #[inline]
  pub fn f(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ViewProperty::VT_F, None)
  }
  #[inline]
  pub fn g(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ViewProperty::VT_G, None)
  }
  #[inline]
  pub fn h(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ViewProperty::VT_H, None)
  }
  #[inline]
  pub fn i(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ViewProperty::VT_I, None)
  }
  #[inline]
  pub fn j(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ViewProperty::VT_J, None)
  }
  #[inline]
  pub fn k(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ViewProperty::VT_K, None)
  }
  #[inline]
  pub fn l(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ViewProperty::VT_L, None)
  }
  #[inline]
  pub fn m(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ViewProperty::VT_M, None)
  }
  #[inline]
  pub fn n(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ViewProperty::VT_N, None)
  }
  #[inline]
  pub fn o(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ViewProperty::VT_O, None)
  }
}

impl flatbuffers::Verifiable for ViewProperty<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .visit_field::<f64>("height", Self::VT_HEIGHT, false)?
     .visit_field::<f64>("margin_left", Self::VT_MARGIN_LEFT, false)?
     .visit_field::<f64>("margin_right", Self::VT_MARGIN_RIGHT, false)?
     .visit_field::<f64>("margin_top", Self::VT_MARGIN_TOP, false)?
     .visit_field::<f64>("margin_bottom", Self::VT_MARGIN_BOTTOM, false)?
     .visit_field::<i32>("flex", Self::VT_FLEX, false)?
     .visit_field::<Display>("display", Self::VT_DISPLAY, false)?
     .visit_field::<FlexDirection>("flex_direction", Self::VT_FLEX_DIRECTION, false)?
     .visit_field::<i32>("background_color", Self::VT_BACKGROUND_COLOR, false)?
     .visit_field::<FlexWrap>("flex_wrap", Self::VT_FLEX_WRAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("content", Self::VT_CONTENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("a", Self::VT_A, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("b", Self::VT_B, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("c", Self::VT_C, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("d", Self::VT_D, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("e", Self::VT_E, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("f", Self::VT_F, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("g", Self::VT_G, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("h", Self::VT_H, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("i", Self::VT_I, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("j", Self::VT_J, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("k", Self::VT_K, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("l", Self::VT_L, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("m", Self::VT_M, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("n", Self::VT_N, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("o", Self::VT_O, false)?
     .finish();
    Ok(())
  }
}
pub struct ViewPropertyArgs<'a> {
    pub width: f64,
    pub height: f64,
    pub margin_left: f64,
    pub margin_right: f64,
    pub margin_top: f64,
    pub margin_bottom: f64,
    pub flex: i32,
    pub display: Display,
    pub flex_direction: FlexDirection,
    pub background_color: i32,
    pub flex_wrap: FlexWrap,
    pub content: Option<flatbuffers::WIPOffset<&'a str>>,
    pub a: Option<flatbuffers::WIPOffset<&'a str>>,
    pub b: Option<flatbuffers::WIPOffset<&'a str>>,
    pub c: Option<flatbuffers::WIPOffset<&'a str>>,
    pub d: Option<flatbuffers::WIPOffset<&'a str>>,
    pub e: Option<flatbuffers::WIPOffset<&'a str>>,
    pub f: Option<flatbuffers::WIPOffset<&'a str>>,
    pub g: Option<flatbuffers::WIPOffset<&'a str>>,
    pub h: Option<flatbuffers::WIPOffset<&'a str>>,
    pub i: Option<flatbuffers::WIPOffset<&'a str>>,
    pub j: Option<flatbuffers::WIPOffset<&'a str>>,
    pub k: Option<flatbuffers::WIPOffset<&'a str>>,
    pub l: Option<flatbuffers::WIPOffset<&'a str>>,
    pub m: Option<flatbuffers::WIPOffset<&'a str>>,
    pub n: Option<flatbuffers::WIPOffset<&'a str>>,
    pub o: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ViewPropertyArgs<'a> {
  #[inline]
  fn default() -> Self {
    ViewPropertyArgs {
      width: 0.0,
      height: 0.0,
      margin_left: 0.0,
      margin_right: 0.0,
      margin_top: 0.0,
      margin_bottom: 0.0,
      flex: 0,
      display: Display::flex,
      flex_direction: FlexDirection::column,
      background_color: 0,
      flex_wrap: FlexWrap::nowrap,
      content: None,
      a: None,
      b: None,
      c: None,
      d: None,
      e: None,
      f: None,
      g: None,
      h: None,
      i: None,
      j: None,
      k: None,
      l: None,
      m: None,
      n: None,
      o: None,
    }
  }
}
pub struct ViewPropertyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ViewPropertyBuilder<'a, 'b> {
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(ViewProperty::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_height(&mut self, height: f64) {
    self.fbb_.push_slot::<f64>(ViewProperty::VT_HEIGHT, height, 0.0);
  }
  #[inline]
  pub fn add_margin_left(&mut self, margin_left: f64) {
    self.fbb_.push_slot::<f64>(ViewProperty::VT_MARGIN_LEFT, margin_left, 0.0);
  }
  #[inline]
  pub fn add_margin_right(&mut self, margin_right: f64) {
    self.fbb_.push_slot::<f64>(ViewProperty::VT_MARGIN_RIGHT, margin_right, 0.0);
  }
  #[inline]
  pub fn add_margin_top(&mut self, margin_top: f64) {
    self.fbb_.push_slot::<f64>(ViewProperty::VT_MARGIN_TOP, margin_top, 0.0);
  }
  #[inline]
  pub fn add_margin_bottom(&mut self, margin_bottom: f64) {
    self.fbb_.push_slot::<f64>(ViewProperty::VT_MARGIN_BOTTOM, margin_bottom, 0.0);
  }
  #[inline]
  pub fn add_flex(&mut self, flex: i32) {
    self.fbb_.push_slot::<i32>(ViewProperty::VT_FLEX, flex, 0);
  }
  #[inline]
  pub fn add_display(&mut self, display: Display) {
    self.fbb_.push_slot::<Display>(ViewProperty::VT_DISPLAY, display, Display::flex);
  }
  #[inline]
  pub fn add_flex_direction(&mut self, flex_direction: FlexDirection) {
    self.fbb_.push_slot::<FlexDirection>(ViewProperty::VT_FLEX_DIRECTION, flex_direction, FlexDirection::column);
  }
  #[inline]
  pub fn add_background_color(&mut self, background_color: i32) {
    self.fbb_.push_slot::<i32>(ViewProperty::VT_BACKGROUND_COLOR, background_color, 0);
  }
  #[inline]
  pub fn add_flex_wrap(&mut self, flex_wrap: FlexWrap) {
    self.fbb_.push_slot::<FlexWrap>(ViewProperty::VT_FLEX_WRAP, flex_wrap, FlexWrap::nowrap);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ViewProperty::VT_CONTENT, content);
  }
  #[inline]
  pub fn add_a(&mut self, a: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ViewProperty::VT_A, a);
  }
  #[inline]
  pub fn add_b(&mut self, b: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ViewProperty::VT_B, b);
  }
  #[inline]
  pub fn add_c(&mut self, c: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ViewProperty::VT_C, c);
  }
  #[inline]
  pub fn add_d(&mut self, d: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ViewProperty::VT_D, d);
  }
  #[inline]
  pub fn add_e(&mut self, e: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ViewProperty::VT_E, e);
  }
  #[inline]
  pub fn add_f(&mut self, f: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ViewProperty::VT_F, f);
  }
  #[inline]
  pub fn add_g(&mut self, g: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ViewProperty::VT_G, g);
  }
  #[inline]
  pub fn add_h(&mut self, h: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ViewProperty::VT_H, h);
  }
  #[inline]
  pub fn add_i(&mut self, i: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ViewProperty::VT_I, i);
  }
  #[inline]
  pub fn add_j(&mut self, j: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ViewProperty::VT_J, j);
  }
  #[inline]
  pub fn add_k(&mut self, k: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ViewProperty::VT_K, k);
  }
  #[inline]
  pub fn add_l(&mut self, l: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ViewProperty::VT_L, l);
  }
  #[inline]
  pub fn add_m(&mut self, m: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ViewProperty::VT_M, m);
  }
  #[inline]
  pub fn add_n(&mut self, n: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ViewProperty::VT_N, n);
  }
  #[inline]
  pub fn add_o(&mut self, o: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ViewProperty::VT_O, o);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ViewPropertyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ViewPropertyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ViewProperty<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for ViewProperty<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("ViewProperty");
      ds.field("width", &self.width());
      ds.field("height", &self.height());
      ds.field("margin_left", &self.margin_left());
      ds.field("margin_right", &self.margin_right());
      ds.field("margin_top", &self.margin_top());
      ds.field("margin_bottom", &self.margin_bottom());
      ds.field("flex", &self.flex());
      ds.field("display", &self.display());
      ds.field("flex_direction", &self.flex_direction());
      ds.field("background_color", &self.background_color());
      ds.field("flex_wrap", &self.flex_wrap());
      ds.field("content", &self.content());
      ds.field("a", &self.a());
      ds.field("b", &self.b());
      ds.field("c", &self.c());
      ds.field("d", &self.d());
      ds.field("e", &self.e());
      ds.field("f", &self.f());
      ds.field("g", &self.g());
      ds.field("h", &self.h());
      ds.field("i", &self.i());
      ds.field("j", &self.j());
      ds.field("k", &self.k());
      ds.field("l", &self.l());
      ds.field("m", &self.m());
      ds.field("n", &self.n());
      ds.field("o", &self.o());
      ds.finish()
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_view_property<'a>(buf: &'a [u8]) -> ViewProperty<'a> {
  unsafe { flatbuffers::root_unchecked::<ViewProperty<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_view_property<'a>(buf: &'a [u8]) -> ViewProperty<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<ViewProperty<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `ViewProperty`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_view_property_unchecked`.
pub fn root_as_view_property(buf: &[u8]) -> Result<ViewProperty, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ViewProperty>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ViewProperty` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_view_property_unchecked`.
pub fn size_prefixed_root_as_view_property(buf: &[u8]) -> Result<ViewProperty, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ViewProperty>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ViewProperty` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_view_property_unchecked`.
pub fn root_as_view_property_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ViewProperty<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ViewProperty<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ViewProperty` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_view_property_unchecked`.
pub fn size_prefixed_root_as_view_property_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ViewProperty<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ViewProperty<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ViewProperty and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ViewProperty`.
pub unsafe fn root_as_view_property_unchecked(buf: &[u8]) -> ViewProperty {
  flatbuffers::root_unchecked::<ViewProperty>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ViewProperty and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ViewProperty`.
pub unsafe fn size_prefixed_root_as_view_property_unchecked(buf: &[u8]) -> ViewProperty {
  flatbuffers::size_prefixed_root_unchecked::<ViewProperty>(buf)
}
#[inline]
pub fn finish_view_property_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<ViewProperty<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_view_property_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<ViewProperty<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
